---
- name: Ensure required packages are installed
  ansible.builtin.apt:
    name: "{{ item }}"
  loop:
    - rsyslog
    - logrotate
    - ufw
    - tailscale
    - fail2ban
    - lynis
  become: true

- name: Ensure syslog user exists
  ansible.builtin.user:
    name: syslog
    system: true

- name: Backup and deploy rsyslog configuration
  block:
    - name: Backup original rsyslog.conf
      ansible.builtin.copy:
        src: /etc/rsyslog.conf
        dest: /etc/rsyslog.conf.bak
        remote_src: true
      become: true

    - name: Deploy custom rsyslog configuration
      ansible.builtin.template:
        src: rsyslog.conf.j2
        dest: /etc/rsyslog.conf
        owner: root
        group: root
        mode: '0644'
      notify: Validate rsyslog configuration

- name: Deploy custom logrotate configuration for rsyslog
  ansible.builtin.template:
    src: logrotate_rsyslog.j2
    dest: /etc/logrotate.d/rsyslog
    owner: root
    group: root
    mode: '0644'
  become: true

- name: Configure UFW rules and service
  block:
    - name: Set default deny policy for incoming traffic
      ansible.builtin.command: ufw default deny incoming
      changed_when: false
      become: true

    - name: Set default allow policy for outgoing traffic
      ansible.builtin.command: ufw default allow outgoing
      changed_when: false
      become: true

    - name: Allow specified TCP ports
      ansible.builtin.command: ufw allow {{ item }}/tcp
      changed_when: false
      loop: "{{ ufw_ports }}"
      become: true

    - name: Allow specified Tailscale UDP ports
      ansible.builtin.command: ufw allow {{ item }}/udp
      changed_when: false
      loop: "{{ tailscale_ports }}"
      become: true

    - name: Allow QUIC and HTTP2 traffic to Cloudflare Tunnel for IPv4 addresses
      ansible.builtin.command: ufw allow proto udp to {{ item }} port {{ cloudflared_quic_port }}
      changed_when: false
      loop: "{{ cloudflare_region1_ips_v4 + cloudflare_region2_ips_v4 }}"
      become: true

    - name: Allow QUIC and HTTP2 traffic to Cloudflare Tunnel for IPv6 addresses
      ansible.builtin.command: ufw allow proto udp to {{ item }} port {{ cloudflared_quic_port }}
      changed_when: false
      loop: "{{ cloudflare_region1_ips_v6 + cloudflare_region2_ips_v6 }}"
      become: true

    - name: Optionally allow HTTPS traffic for Cloudflare services (IPv4)
      ansible.builtin.command: ufw allow proto tcp to {{ item }} port {{ cloudflared_https_port }}
      changed_when: false
      loop: "{{ cloudflare_region1_ips_v4 + cloudflare_region2_ips_v4 }}"
      become: true

    - name: Optionally allow HTTPS traffic for Cloudflare services (IPv6)
      ansible.builtin.command: ufw allow proto tcp to {{ item }} port {{ cloudflared_https_port }}
      changed_when: false
      loop: "{{ cloudflare_region1_ips_v6 + cloudflare_region2_ips_v6 }}"
      become: true

    - name: Open necessary ports for WARP and WireGuard
      ansible.builtin.command: ufw allow {{ item }}/udp
      changed_when: false
      loop: "{{ warp_wireguard_ports }}"
      become: true

    - name: Allow Cloudflare WARP IP ranges
      ansible.builtin.command: ufw allow from {{ item }}
      changed_when: false
      loop: "{{ cloudflare_warp_ips }}"
      become: true

    - name: Open necessary ports for QUIC (UDP 443)
      ansible.builtin.command: ufw allow 443/udp
      changed_when: false
      become: true

    - name: Allow UDP port 10000 for Jitsi media streaming
      ansible.builtin.command: ufw allow 10000/udp
      changed_when: false
      become: true

    - name: Ensure UFW logging is off
      ansible.builtin.command: ufw logging off
      changed_when: false
      become: true

    - name: Reload UFW to apply changes
      ansible.builtin.command: ufw reload
      changed_when: false
      become: true

    - name: Check UFW status
      ansible.builtin.command: ufw status verbose
      register: ufw_status
      become: true

    - name: Display UFW status
      ansible.builtin.debug:
        msg: '{{ ufw_status.stdout }}'
  become: true

- name: Ensure UFW is enabled (finalize firewall)
  ansible.builtin.command: ufw --force enable
  changed_when: false
  when: ufw_enable | default(true)
  become: true

- name: Check UFW status (post-enable)
  ansible.builtin.command: ufw status verbose
  register: ufw_status_post
  changed_when: false
  become: true

- name: Display UFW status (post-enable)
  ansible.builtin.debug:
    msg: '{{ ufw_status_post.stdout }}'

- name: Retrieve Tailscale status
  ansible.builtin.command: tailscale status
  register: tailscale_status
  changed_when: false

- name: Check if Tailscale needs to be started
  ansible.builtin.set_fact:
    tailscale_needs_start: "{{ tailscale_status.stdout is not regex('.*100\\..*') }}"

- name: Start Tailscale only if not already connected
  ansible.builtin.command: tailscale up --advertise-tags=tag:ssh-access --ssh --accept-dns=false --reset --accept-risk=lose-ssh
  when: tailscale_needs_start | bool
  register: tailscale_start

- name: Retrieve and parse Tailscale IP addresses
  block:
    - name: Retrieve Tailscale status
      ansible.builtin.command: tailscale status --json
      register: tailscale_status

    - name: Set Tailscale IPs
      ansible.builtin.set_fact:
        tailscale_ips: "{{ tailscale_status.stdout | from_json | json_query('Peer.*.TailscaleIPs') | flatten | select('match', '100\\..*') | list }}"

    - name: Allow SSH from Tailscale IPs
      ansible.builtin.command: ufw allow proto tcp from {{ item }} to any port 22
      changed_when: false
      loop: "{{ tailscale_ips }}"

    - name: Allow SSH from self Tailscale IP
      ansible.builtin.command: ufw allow proto tcp from {{ ansible_default_ipv4.address }} to any port 22
      changed_when: false
  become: true

- name: Configure SSH settings
  ansible.builtin.lineinfile:
    path: /etc/ssh/sshd_config
    create: true
    line: '{{ item }}'
  loop:
    - 'Port 22'
    - 'Port 2222'
    - 'AuthorizedKeysFile .ssh/authorized_keys'
    - 'RSAAuthentication yes'
    - 'PubkeyAuthentication yes'
    - 'AllowTcpForwarding yes'
    - 'ClientAliveCountMax 3'
    - 'Compression no'
    - 'LogLevel INFO'
    - 'MaxAuthTries 10'
    - 'MaxSessions 10'
    - 'TCPKeepAlive yes'
    - 'X11Forwarding no'
    - 'AllowAgentForwarding yes'
  notify: Restart SSH service

- name: Backup and deploy fail2ban configuration
  block:
    - name: Backup original jail.conf
      ansible.builtin.copy:
        src: /etc/fail2ban/jail.conf
        dest: /etc/fail2ban/jail.conf.bak
        remote_src: true
      become: true

    - name: Deploy fail2ban configuration
      ansible.builtin.template:
        src: jail.local.j2
        dest: /etc/fail2ban/jail.local
        owner: root
        group: root
        mode: '0644'
      notify: Restart fail2ban

- name: Ensure fail2ban service is enabled and started
  ansible.builtin.systemd:
    name: fail2ban
    enabled: true
    state: started
  become: true

- name: Check fail2ban status for sshd
  ansible.builtin.command: fail2ban-client status sshd
  register: result
  failed_when: "'sshd' not in result.stdout"
  become: true

- name: Debug fail2ban status
  ansible.builtin.debug:
    msg: '{{ result.stdout }}'

- name: Install and Configure CrowdSec with Firewall Bouncer
  become: true
  block:
    - name: Add CrowdSec repository and install CrowdSec
      ansible.builtin.shell: |
        curl -s https://install.crowdsec.net | sudo sh
        apt install -y crowdsec
      register: crowdsec_install
      changed_when: "'CrowdSec installed' not in crowdsec_install.stdout"

    - name: Install firewall bouncer
      ansible.builtin.apt:
        name: crowdsec-firewall-bouncer

    - name: Create required directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - /etc/crowdsec/bouncers
        - /etc/crowdsec/parsers/s02-enrich

    - name: Configure main CrowdSec config
      ansible.builtin.template:
        src: crowdsec-config.yaml.j2
        dest: /etc/crowdsec/config.yaml
        mode: '0600'
      notify: Restart crowdsec

    - name: Configure CrowdSec whitelist
      ansible.builtin.template:
        src: crowdsec-whitelists.yaml.j2
        dest: /etc/crowdsec/parsers/s02-enrich/whitelists.yaml
        mode: '0600'
      notify: Restart crowdsec

    # データベース初期化のステップを追加
    - name: Initialize CrowdSec database
      ansible.builtin.command: cscli hub update
      register: hub_update
      changed_when: hub_update.rc == 0
      failed_when: false

    - name: Ensure CrowdSec service is started
      ansible.builtin.systemd:
        name: crowdsec
        state: started
        enabled: true

    - name: Wait for CrowdSec to be ready
      ansible.builtin.wait_for:
        timeout: 10

    - name: Remove existing bouncer
      ansible.builtin.command: cscli bouncers delete crowdsec-firewall-bouncer
      register: bouncer_delete
      failed_when:
        - bouncer_delete.rc != 0
        - "'bouncer not found' not in bouncer_delete.stderr"
      changed_when: bouncer_delete.rc == 0

    - name: Add new bouncer
      ansible.builtin.command: cscli bouncers add crowdsec-firewall-bouncer
      register: bouncer_token
      changed_when: true

    - name: Debug full bouncer token output
      ansible.builtin.debug:
        msg:
          - "stdout: {{ bouncer_token.stdout }}"
          - "stdout_lines: {{ bouncer_token.stdout_lines }}"
        verbosity: 0

    - name: Extract API key
      ansible.builtin.set_fact:
        bouncer_api_key: "{{ bouncer_token.stdout_lines[2] | trim }}"

    - name: Configure bouncer
      ansible.builtin.template:
        src: crowdsec-firewall-bouncer.yaml.j2
        dest: /etc/crowdsec/bouncers/crowdsec-firewall-bouncer.yaml
        mode: '0600'
        owner: root
        group: root
      notify: Restart crowdsec-firewall-bouncer

    - name: Ensure services are enabled and started
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: started
        enabled: true
      loop:
        - crowdsec
        - crowdsec-firewall-bouncer

- name: Ensure ClamAV configuration
  block:
    - name: Ensure log directory for ClamAV exists
      ansible.builtin.file:
        path: /var/log/clamav
        state: directory
        owner: clamav
        group: adm
        mode: '0755'
      become: true

    - name: Configure ClamAV daemon settings
      ansible.builtin.template:
        src: clamd.conf.j2
        dest: /etc/clamav/clamd.conf
        owner: root
        group: root
        mode: '0644'
      notify: Restart clamav-daemon
      become: true

    - name: Ensure freshclam log file is writable
      ansible.builtin.file:
        path: /var/log/clamav/freshclam.log
        state: touch
        owner: clamav
        group: adm
        mode: '0644'
      become: true

    - name: Update ClamAV virus database
      ansible.builtin.command: freshclam
      become: true
      failed_when: false
      changed_when: false

    - name: Ensure ClamAV daemon is started and enabled
      ansible.builtin.systemd:
        name: clamav-daemon
        state: started
        enabled: true
      become: true

    - name: Schedule daily ClamAV scan (JST 4:00 AM)
      ansible.builtin.cron:
        name: 'Daily ClamAV scan'
        minute: '0'
        hour: '19'    # UTC 19:00 = JST 04:00
        job: "/usr/bin/timeout 1h45m /usr/bin/nice -n 19 /usr/bin/clamdscan -m --fdpass --config-file=/etc/clamav/clamd.conf -l /var/log/clamav/clamav-$(date +\\%Y\\%m\\%d).log /"
      become: true

- name: Configure sysctl settings only if needed
  block:
    - name: Check if sysctl settings need to be applied
      ansible.builtin.command: "sysctl -n {{ item.name }}"
      register: current_value
      loop: "{{ sysctl_settings }}"
      changed_when: current_value.stdout != item.value

    - name: Apply sysctl settings if changes are detected
      ansible.posix.sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        reload: true
      loop: "{{ sysctl_settings }}"
  notify: Reload sysctl
  become: true

- name: Reload sysctl
  ansible.builtin.command: sysctl -p
  become: true

- name: Setup dnscrypt-proxy (System Install)
  block:
    - name: Install dnscrypt-proxy
      ansible.builtin.package:
        name: dnscrypt-proxy

    - name: Ensure dnscrypt-proxy configuration directory exists
      ansible.builtin.file:
        path: /etc/dnscrypt-proxy
        state: directory
        mode: '0755'

    - name: Deploy dnscrypt-proxy configuration
      ansible.builtin.template:
        src: dnscrypt-proxy.toml.j2
        dest: /etc/dnscrypt-proxy/dnscrypt-proxy.toml
        mode: '0644'
      notify: Restart dnscrypt-proxy

    - name: Enable and start dnscrypt-proxy service
      ansible.builtin.systemd:
        name: dnscrypt-proxy
        state: started
        enabled: true
  become: true

- name: Configure systemd-resolved to use dnscrypt-proxy
  block:
    - name: Configure systemd-resolved DNS settings
      ansible.builtin.template:
        src: resolved.conf.j2
        dest: /etc/systemd/resolved.conf
        mode: '0644'
      notify: Restart systemd-resolved

    - name: Ensure systemd-resolved is enabled and started
      ansible.builtin.systemd:
        name: systemd-resolved
        state: started
        enabled: true

    - name: Ensure correct resolv.conf configuration
      ansible.builtin.file:
        src: /run/systemd/resolve/stub-resolv.conf
        dest: /etc/resolv.conf
        state: link
        force: true

    - name: Configure Docker daemon DNS settings
      ansible.builtin.copy:
        dest: /etc/docker/daemon.json
        content: |
          {
            "dns": ["127.0.0.1", "1.1.1.1"],
            "dns-opts": ["use-vc"],
            "dns-search": []
          }
        mode: '0644'
      notify: Restart Docker
  become: true

- name: Verify DNS configuration
  block:
    - name: Test DNS resolution with dig
      ansible.builtin.command: dig @127.0.0.1 cloudflare.com
      register: dig_result
      changed_when: false

    - name: Test DNS resolution with nslookup
      ansible.builtin.command: nslookup cloudflare.com 127.0.0.1
      register: nslookup_result
      changed_when: false

    - name: Test SRV record resolution with dig
      ansible.builtin.command: dig @127.0.0.1 srv _origintunneld._tcp.argotunnel.com
      register: srv_dig_result
      changed_when: false

    - name: Display DNS test results
      ansible.builtin.debug:
        msg: |
          dig result: {{ dig_result.stdout }}
          nslookup result: {{ nslookup_result.stdout }}
          SRV dig result: {{ srv_dig_result.stdout }}
  become: true
