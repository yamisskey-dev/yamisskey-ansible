---
- name: Ensure required packages are installed
  ansible.builtin.apt:
    name: "{{ item }}"
  loop:
    - rsyslog
    - logrotate
    - ufw
    - lynis
    - curl
    - dnsutils
  become: true

- name: Ensure syslog user exists
  ansible.builtin.user:
    name: syslog
    system: true

- name: Backup and deploy rsyslog configuration
  block:
    - name: Backup original rsyslog.conf
      ansible.builtin.copy:
        src: /etc/rsyslog.conf
        dest: /etc/rsyslog.conf.bak
        remote_src: true
      become: true

    - name: Deploy custom rsyslog configuration
      ansible.builtin.template:
        src: rsyslog.conf.j2
        dest: /etc/rsyslog.conf
        owner: root
        group: root
        mode: '0644'
      notify: Validate rsyslog configuration
      tags: ['security', 'rsyslog']
  when: (ansible_become | default(false)) | bool

- name: Deploy custom logrotate configuration for rsyslog
  ansible.builtin.template:
    src: logrotate_rsyslog.j2
    dest: /etc/logrotate.d/rsyslog
    owner: root
    group: root
    mode: '0644'
  become: true
  when: (ansible_become | default(false)) | bool

- name: Configure UFW rules and service
  block:
    - name: Set default deny policy for incoming traffic
      ansible.builtin.command: ufw default deny incoming
      changed_when: false
      become: true

    - name: Set default allow policy for outgoing traffic
      ansible.builtin.command: ufw default allow outgoing
      changed_when: false
      become: true

    - name: Allow specified TCP ports
      ansible.builtin.command: ufw allow {{ item }}/tcp
      changed_when: false
      loop: "{{ security_ufw_ports }}"
      become: true

    - name: Allow QUIC and HTTP2 traffic to Cloudflare Tunnel for IPv4 addresses
      ansible.builtin.command: ufw allow proto udp to {{ item }} port {{ security_cloudflared_quic_port }}
      changed_when: false
      loop: "{{ security_cloudflare_region1_ips_v4 + security_cloudflare_region2_ips_v4 }}"
      become: true

    - name: Allow QUIC and HTTP2 traffic to Cloudflare Tunnel for IPv6 addresses
      ansible.builtin.command: ufw allow proto udp to {{ item }} port {{ security_cloudflared_quic_port }}
      changed_when: false
      loop: "{{ security_cloudflare_region1_ips_v6 + security_cloudflare_region2_ips_v6 }}"
      become: true

    - name: Optionally allow HTTPS traffic for Cloudflare services (IPv4)
      ansible.builtin.command: ufw allow proto tcp to {{ item }} port {{ security_cloudflared_https_port }}
      changed_when: false
      loop: "{{ security_cloudflare_region1_ips_v4 + security_cloudflare_region2_ips_v4 }}"
      become: true

    - name: Optionally allow HTTPS traffic for Cloudflare services (IPv6)
      ansible.builtin.command: ufw allow proto tcp to {{ item }} port {{ security_cloudflared_https_port }}
      changed_when: false
      loop: "{{ security_cloudflare_region1_ips_v6 + security_cloudflare_region2_ips_v6 }}"
      become: true

    - name: Open necessary ports for WARP and WireGuard
      ansible.builtin.command: ufw allow {{ item }}/udp
      changed_when: false
      loop: "{{ security_warp_wireguard_ports }}"
      become: true

    - name: Allow Cloudflare WARP IP ranges
      ansible.builtin.command: ufw allow from {{ item }}
      changed_when: false
      loop: "{{ security_cloudflare_warp_ips }}"
      become: true

    - name: Open necessary ports for QUIC (UDP 443)
      ansible.builtin.command: ufw allow 443/udp
      changed_when: false
      become: true

    - name: Allow Docker networks to access monitoring ports
      ansible.builtin.command: ufw allow from {{ item.0 }} to any port {{ item.1 }}
      changed_when: false
      loop: "{{ security_docker_networks | product(security_monitoring_ports) | list }}"
      become: true
      when: security_docker_monitoring_enabled | default(true)

    - name: Ensure UFW logging is off
      ansible.builtin.command: ufw logging off
      changed_when: false
      become: true

    - name: Reload UFW to apply changes
      ansible.builtin.command: ufw reload
      changed_when: false
      become: true

    - name: Check UFW status
      ansible.builtin.command: ufw status verbose
      register: ufw_status
      become: true
      changed_when: false

    - name: Display UFW status
      ansible.builtin.debug:
        msg: '{{ ufw_status.stdout }}'
  become: true
  when: (ansible_become | default(false)) | bool

- name: Ensure UFW is enabled (finalize firewall)
  ansible.builtin.command: ufw --force enable
  changed_when: false
  become: true
  when:
    - security_ufw_enable | default(true)
    - (ansible_become | default(false)) | bool
- name: Check UFW status (post-enable)
  ansible.builtin.command: ufw status verbose
  register: ufw_status_post
  changed_when: false
  become: true
  when: (ansible_become | default(false)) | bool
- name: Display UFW status (post-enable)
  ansible.builtin.debug:
    msg: '{{ ufw_status_post.stdout }}'
  when:
    - ufw_status_post is defined
    - (ansible_become | default(false)) | bool

- name: Configure SSH settings
  ansible.builtin.lineinfile:
    path: /etc/ssh/sshd_config
    create: true
    line: '{{ item }}'
  loop:
    - 'Port 22'
    - 'Port 2222'
    - 'AuthorizedKeysFile .ssh/authorized_keys'
    - 'RSAAuthentication yes'
    - 'PubkeyAuthentication yes'
    - 'AllowTcpForwarding yes'
    - 'ClientAliveCountMax 3'
    - 'Compression no'
    - 'LogLevel INFO'
    - 'MaxAuthTries 10'
    - 'MaxSessions 10'
    - 'TCPKeepAlive yes'
    - 'X11Forwarding no'
    - 'AllowAgentForwarding yes'
  notify: Restart SSH service

- name: Ensure ClamAV configuration
  block:
    - name: Ensure log directory for ClamAV exists
      ansible.builtin.file:
        path: /var/log/clamav
        state: directory
        owner: clamav
        group: adm
        mode: '0755'
      become: true

    - name: Configure ClamAV daemon settings
      ansible.builtin.template:
        src: clamd.conf.j2
        dest: /etc/clamav/clamd.conf
        owner: root
        group: root
        mode: '0644'
      notify: Restart clamav-daemon
      become: true

    - name: Ensure freshclam log file is writable
      ansible.builtin.file:
        path: /var/log/clamav/freshclam.log
        state: touch
        owner: clamav
        group: adm
        mode: '0644'
      become: true

    - name: Update ClamAV virus database
      ansible.builtin.command: freshclam
      become: true
      failed_when: false
      changed_when: false

    - name: Ensure ClamAV daemon is started and enabled
      ansible.builtin.systemd:
        name: clamav-daemon
        state: started
        enabled: true
      become: true

    - name: Schedule daily ClamAV scan (JST 4:00 AM)
      ansible.builtin.cron:
        name: 'Daily ClamAV scan'
        minute: '0'
        hour: '19'    # UTC 19:00 = JST 04:00
        job: "/usr/bin/timeout 1h45m /usr/bin/nice -n 19 /usr/bin/clamdscan -m --fdpass --config-file=/etc/clamav/clamd.conf -l /var/log/clamav/clamav-$(date +%Y%m%d).log /"
      become: true
  when:
    - security_manage_clamav | default(true)
    - ansible_virtualization_type is not defined or ansible_virtualization_type not in ['docker', 'container']

- name: Configure sysctl settings only if needed
  block:
    - name: Check if sysctl settings need to be applied
      ansible.builtin.command: "sysctl -n {{ item.name }}"
      register: current_value
      loop: "{{ security_sysctl_settings }}"
      changed_when: current_value.stdout != item.value

    - name: Apply sysctl settings if changes are detected
      ansible.posix.sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        reload: true
      loop: "{{ security_sysctl_settings }}"
  notify: Reload sysctl
  become: true
  when: ansible_virtualization_type is not defined or ansible_virtualization_type not in ['docker', 'container']

# =============================================================================
# カーネルハードニング (eBPF/grsecurity/PaX相当)
# =============================================================================

- name: Configure kernel hardening (GRUB and module blacklist)
  block:
    - name: Backup original GRUB configuration
      ansible.builtin.copy:
        src: /etc/default/grub
        dest: /etc/default/grub.bak
        remote_src: true
        force: false
      become: true

    - name: Read current GRUB configuration
      ansible.builtin.slurp:
        src: /etc/default/grub
      register: grub_config
      become: true

    - name: Build kernel hardening parameters string
      ansible.builtin.set_fact:
        kernel_hardening_params: "{{ security_grub_cmdline_extra | join(' ') }}"

    - name: Update GRUB_CMDLINE_LINUX_DEFAULT with hardening parameters
      ansible.builtin.lineinfile:
        path: /etc/default/grub
        regexp: '^GRUB_CMDLINE_LINUX_DEFAULT='
        line: 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash {{ kernel_hardening_params }}"'
        backrefs: false
      become: true
      register: grub_updated
      notify: Update GRUB

    - name: Ensure modprobe.d directory exists
      ansible.builtin.file:
        path: /etc/modprobe.d
        state: directory
        mode: '0755'
      become: true

    - name: Create kernel module blacklist for security
      ansible.builtin.template:
        src: modprobe-blacklist.conf.j2
        dest: /etc/modprobe.d/security-blacklist.conf
        owner: root
        group: root
        mode: '0644'
      become: true

    - name: Create module loading prevention rules
      ansible.builtin.copy:
        dest: /etc/modprobe.d/security-prevent.conf
        content: |
          # Prevent loading of blacklisted modules by returning false
          {% for module in security_kernel_module_blacklist %}
          install {{ module }} /bin/false
          {% endfor %}
        owner: root
        group: root
        mode: '0644'
      become: true

    - name: Unload currently loaded blacklisted modules
      ansible.builtin.shell: |
        for mod in {{ security_kernel_module_blacklist | join(' ') }}; do
          if lsmod | grep -q "^${mod}"; then
            modprobe -r "$mod" 2>/dev/null || true
          fi
        done
      become: true
      changed_when: false
      failed_when: false

  when:
    - security_kernel_hardening_enabled | default(true)
    - ansible_virtualization_type is not defined or ansible_virtualization_type not in ['docker', 'container']

- name: Configure kernel lockdown mode
  block:
    - name: Check if lockdown is available
      ansible.builtin.stat:
        path: /sys/kernel/security/lockdown
      register: lockdown_file

    - name: Display lockdown availability
      ansible.builtin.debug:
        msg: "Kernel lockdown is {{ 'available' if lockdown_file.stat.exists else 'not available (kernel too old or not configured)' }}"

    - name: Read current lockdown mode
      ansible.builtin.slurp:
        src: /sys/kernel/security/lockdown
      register: current_lockdown
      when: lockdown_file.stat.exists

    - name: Display current lockdown mode
      ansible.builtin.debug:
        msg: "Current lockdown mode: {{ current_lockdown.content | b64decode | trim }}"
      when: lockdown_file.stat.exists
  become: true
  when:
    - security_kernel_hardening_enabled | default(true)
    - ansible_virtualization_type is not defined or ansible_virtualization_type not in ['docker', 'container']

- name: Setup dnscrypt-proxy (System Install)
  block:
    - name: Install dnscrypt-proxy
      ansible.builtin.package:
        name: dnscrypt-proxy
      register: dnscrypt_install_result

    - name: Verify dnscrypt-proxy installation
      ansible.builtin.command:
        cmd: which dnscrypt-proxy
      register: dnscrypt_which_result
      failed_when: false
      changed_when: false

    - name: Debug dnscrypt-proxy installation
      debug:
        msg: "dnscrypt-proxy installation: {{ dnscrypt_install_result.changed }}, found at: {{ dnscrypt_which_result.stdout }}"

    - name: Ensure dnscrypt-proxy configuration directory exists
      ansible.builtin.file:
        path: /etc/dnscrypt-proxy
        state: directory
        mode: '0755'

    - name: Deploy dnscrypt-proxy configuration
      ansible.builtin.template:
        src: dnscrypt-proxy.toml.j2
        dest: /etc/dnscrypt-proxy/dnscrypt-proxy.toml
        mode: '0644'
      notify: Restart dnscrypt-proxy

    - name: Enable and start dnscrypt-proxy service
      ansible.builtin.systemd:
        name: dnscrypt-proxy
        state: started
        enabled: true
      when: dnscrypt_which_result.rc == 0
  become: true
  when: ansible_virtualization_type is not defined or ansible_virtualization_type not in ['docker', 'container']

- name: Configure systemd-resolved to use dnscrypt-proxy
  block:
    - name: Configure systemd-resolved DNS settings
      ansible.builtin.template:
        src: resolved.conf.j2
        dest: /etc/systemd/resolved.conf
        mode: '0644'
      notify: Restart systemd-resolved

    - name: Ensure systemd-resolved is enabled and started
      ansible.builtin.systemd:
        name: systemd-resolved
        state: started
        enabled: true

    - name: Ensure correct resolv.conf configuration
      ansible.builtin.file:
        src: /run/systemd/resolve/stub-resolv.conf
        dest: /etc/resolv.conf
        state: link
        force: true

    - name: Configure Docker daemon DNS settings
      ansible.builtin.copy:
        dest: /etc/docker/daemon.json
        content: |
          {
            "dns": ["127.0.0.1", "1.1.1.1"],
            "dns-opts": ["use-vc"],
            "dns-search": []
          }
        mode: '0644'
      notify: Restart Docker
  become: true
  when: ansible_virtualization_type is not defined or ansible_virtualization_type not in ['docker', 'container']

- name: Verify DNS configuration
  block:
    - name: Check if dig command is available
      ansible.builtin.command: command -v dig
      register: dig_available
      changed_when: false
      failed_when: false

    - name: Test DNS resolution with dig
      ansible.builtin.command: dig @127.0.0.1 cloudflare.com
      register: dig_result
      changed_when: false
      failed_when: false
      when: dig_available.rc == 0

    - name: Test DNS resolution with nslookup
      ansible.builtin.command: nslookup cloudflare.com 127.0.0.1
      register: nslookup_result
      changed_when: false
      failed_when: false

    - name: Test SRV record resolution with dig
      ansible.builtin.command: dig @127.0.0.1 srv _origintunneld._tcp.argotunnel.com
      register: srv_dig_result
      changed_when: false
      failed_when: false
      when: dig_available.rc == 0

    - name: Display DNS test results
      ansible.builtin.debug:
        msg: |
          dig result: {{ dig_result.stdout | default('dig command not available') }}
          nslookup result: {{ nslookup_result.stdout | default('DNS test not available') }}
          SRV dig result: {{ srv_dig_result.stdout | default('dig command not available') }}
  become: true
  when:
    - ansible_env.MOLECULE_SCENARIO_NAME is not defined
    - ansible_virtualization_type is not defined or ansible_virtualization_type not in ['docker', 'container']
